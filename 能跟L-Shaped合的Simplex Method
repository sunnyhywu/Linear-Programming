/*
 How to Pass Parameters for L-Shaped Method
If you want to integrate this class with an L-Shaped method, you would typically generate the following inputs dynamically:

LHS Matrix: The constraint matrix of your problem.
RHS Vector: The right-hand side values.
Objective Coefficients: The coefficients of the objective function.
In your L-Shaped method, you can create and initialize an instance of this class as follows:

csharp
複製程式碼
// Inside your L-Shaped method:
double[,] lhs = GenerateLHS(); // Replace with your matrix generator logic
double[] rhs = GenerateRHS(); // Replace with your RHS generator logic
double[] objCoeffs = GenerateObjectiveCoefficients(); // Replace with your logic
int totalVars = objCoeffs.Length;
int numConstraints = rhs.Length;

SimplexSolver simplexSolver = new SimplexSolver(lhs, rhs, objCoeffs, totalVars, numConstraints);
simplex.Solve();
var (optimalValue, primalSolution, shadowPrices) = simplexSolver.GetSolutionDetails();

Example input:

    private double[,] GenerateLHSMatrix()
        {
            {
                { 2, 1, 1, 0 },
                { 1, 2, 0, 1 }
            };
        }
    
        private double[] GenerateRHSVector()
        {
            return new double[] { 4, 6 };
        }
    
        private double[] GenerateObjectiveCoefficients()
        {
            return new double[] { 3, 2, 0, 0 };
        }

Example outcome:
Optimal Value: 10.00
Primal Solution:
x1 = 2.00
x2 = 1.00
x3 = 0.00
x4 = 0.00
Shadow Prices:
Constraint 1: 1.00
Constraint 2: 1.00
*/


using System;
using System.Diagnostics;

using System;
using System.Collections.Generic;
using System.Diagnostics;

class SimplexSolver
{
    // Fields to store the problem data
    private double[] objCoeffs;
    private double[] rhs;
    private double[,] lhs;
    private int totalVars;
    private int numConstraints;

    private double optimalValue;
    private double[] primalSolution;
    private double[] shadowPrices;

    // Constructor to initialize the simplex solver
    public SimplexSolver(double[,] lhs, double[] rhs, double[] objCoeffs, int totalVars, int numConstraints)
    {
        this.lhs = lhs;
        this.rhs = rhs;
        this.objCoeffs = objCoeffs;
        this.totalVars = totalVars;
        this.numConstraints = numConstraints;
    }

    // Method to determine which simplex method to use
    public void Solve()
    {
        if (CheckUnboundedness())
        {
            Console.WriteLine("The problem is unbounded.");
            return;
        }

        string method = DetermineSimplexMethod();
        Console.WriteLine($"Using the {method} method.");

        switch (method)
        {
         
            case "Primal":
                SolveUsingPrimalSimplex();
                break;

            case "Dual":
                SolveUsingDualSimplex();
                break;

            default:
                Console.WriteLine("Unknown method.");
                break;
        }
    }

    private bool CheckUnboundedness()
    {
        for (int j = 0; j < totalVars; j++)
        {
            if (objCoeffs[j] > 1e-6)
            {
                bool isBounded = false;
                for (int i = 0; i < numConstraints; i++)
                {
                    if (lhs[i, j] > 1e-6)
                    {
                        isBounded = true;
                        break;
                    }
                }
                if (!isBounded)
                {
                    return true; // Unbounded in this direction
                }
            }
        }
        return false; // No unbounded direction found
    }

    private string DetermineSimplexMethod()
    {
        bool all_bi_nonnegative = true;
        bool all_cN_nonpositive = true;

        foreach (double bi in rhs)
        {
            if (bi < 0) all_bi_nonnegative = false;
        }

        foreach (double cN in objCoeffs)
        {
            if (cN > 0) all_cN_nonpositive = false;
        }

        if (all_bi_nonnegative && all_cN_nonpositive)
        {
            return "Optimal";
        }
        else if (all_bi_nonnegative)
        {
            return "Primal";
        }
        else if (!all_bi_nonnegative && all_cN_nonpositive)
        {
            return "Dual";
        }
        else
        {
            return "TwoPhase";
        }
    }

    private void SolveUsingPrimalSimplex()
    {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();

        bool shouldContinue = true;
        int iterationCount = 0;
        int originalVars = totalVars - numConstraints;

        // Initialize basic variables (slack variables)
        int[] basicVariables = new int[numConstraints];
        for (int i = 0; i < numConstraints; i++)
        {
            basicVariables[i] = originalVars + i;
        }

        while (shouldContinue)
        {
            iterationCount++;
            Console.WriteLine($"\n--- Iteration {iterationCount} ---");

            // Calculate the dual variables (pi)
            double[] pi = new double[numConstraints];
            for (int i = 0; i < numConstraints; i++)
            {
                pi[i] = objCoeffs[basicVariables[i]];
            }

            // Compute reduced costs for all variables
            double[] reducedCosts = new double[totalVars];
            for (int j = 0; j < totalVars; j++)
            {
                reducedCosts[j] = objCoeffs[j];
                for (int i = 0; i < numConstraints; i++)
                {
                    reducedCosts[j] -= pi[i] * lhs[i, j];
                }
            }

            // Identify the entering variable (most positive reduced cost)
            int enteringVarIndex = -1;
            double maxReducedCost = 0;
            for (int j = 0; j < totalVars; j++)
            {
                if (reducedCosts[j] > maxReducedCost)
                {
                    maxReducedCost = reducedCosts[j];
                    enteringVarIndex = j;
                }
            }

            // If no entering variable is found, the solution is optimal
            if (enteringVarIndex == -1)
            {
                Console.WriteLine("Optimal solution found.");
                shouldContinue = false;
                break;
            }

            Console.WriteLine($"Chosen entering variable: x{enteringVarIndex + 1}");

            // Perform ratio test to select leaving variable
            int leavingVarIndex = -1;
            double minRatio = double.MaxValue;
            for (int i = 0; i < numConstraints; i++)
            {
                if (lhs[i, enteringVarIndex] > 0)
                {
                    double ratio = rhs[i] / lhs[i, enteringVarIndex];
                    if (ratio < minRatio)
                    {
                        minRatio = ratio;
                        leavingVarIndex = i;
                    }
                }
            }

            // If no leaving variable is found, the problem is unbounded
            if (leavingVarIndex == -1)
            {
                Console.WriteLine("Problem is unbounded.");
                shouldContinue = false;
                break;
            }

            Console.WriteLine($"Chosen leaving variable: x{basicVariables[leavingVarIndex] + 1}");

            // Perform pivot operation
            double pivotElement = lhs[leavingVarIndex, enteringVarIndex];

            // Update the leaving row in-place
            for (int j = 0; j < totalVars; j++)
            {
                lhs[leavingVarIndex, j] /= pivotElement;
            }
            rhs[leavingVarIndex] /= pivotElement;

            // Update all other rows in-place
            for (int i = 0; i < numConstraints; i++)
            {
                if (i != leavingVarIndex)
                {
                    double factor = lhs[i, enteringVarIndex];
                    for (int j = 0; j < totalVars; j++)
                    {
                        lhs[i, j] -= factor * lhs[leavingVarIndex, j];
                    }
                    rhs[i] -= factor * rhs[leavingVarIndex];
                }
            }

            // Update the objective coefficients in-place
            double objectiveFactor = objCoeffs[enteringVarIndex];
            for (int j = 0; j < totalVars; j++)
            {
                objCoeffs[j] -= objectiveFactor * lhs[leavingVarIndex, j];
            }

            // Update the basic variable index in-place
            basicVariables[leavingVarIndex] = enteringVarIndex;
        }

        StoreSolution(basicVariables);
        stopwatch.Stop();
        Console.WriteLine($"Total runtime for Primal method: {stopwatch.Elapsed.TotalSeconds} seconds");
    }

    private void SolveUsingDualSimplex()
    {
        Console.WriteLine("\n--- Starting Dual Simplex Method ---");

        int iterationCount = 0;
        bool shouldContinue = true;

        // Initialize basic variables
        int[] basicVariables = new int[numConstraints];
        for (int i = 0; i < numConstraints; i++)
        {
            basicVariables[i] = totalVars - numConstraints + i; // Slack variables
        }

        while (shouldContinue)
        {
            iterationCount++;
            Console.WriteLine($"\n--- Iteration {iterationCount} ---");

            // Step 1: Identify the most negative RHS entry (leaving variable)
            int leavingVarIndex = -1;
            double mostNegativeRHS = 0;
            for (int i = 0; i < numConstraints; i++)
            {
                if (rhs[i] < mostNegativeRHS)
                {
                    mostNegativeRHS = rhs[i];
                    leavingVarIndex = i;
                }
            }

            // If no negative RHS, the solution is optimal
            if (leavingVarIndex == -1)
            {
                Console.WriteLine("Optimal solution found.");
                shouldContinue = false;
                break;
            }

            Console.WriteLine($"Leaving variable: x{basicVariables[leavingVarIndex] + 1}");

            // Step 2: Select entering variable using the dual feasibility ratio test
            int enteringVarIndex = -1;
            double minRatio = double.MaxValue;
            for (int j = 0; j < totalVars; j++)
            {
                if (lhs[leavingVarIndex, j] < 0) // Only consider negative coefficients in the leaving row
                {
                    double reducedCost = objCoeffs[j];
                    for (int i = 0; i < numConstraints; i++)
                    {
                        reducedCost -= objCoeffs[basicVariables[i]] * lhs[i, j];
                    }

                    double ratio = Math.Abs(reducedCost / lhs[leavingVarIndex, j]);
                    if (ratio < minRatio)
                    {
                        minRatio = ratio;
                        enteringVarIndex = j;
                    }
                }
            }

            // If no entering variable is found, the problem is infeasible
            if (enteringVarIndex == -1)
            {
                Console.WriteLine("Problem is infeasible.");
                return;
            }

            Console.WriteLine($"Entering variable: x{enteringVarIndex + 1}");

            // Step 3: Perform pivot operation
            double pivotElement = lhs[leavingVarIndex, enteringVarIndex];

            // Normalize the leaving row
            for (int j = 0; j < totalVars; j++)
            {
                lhs[leavingVarIndex, j] /= pivotElement;
            }
            rhs[leavingVarIndex] /= pivotElement;

            // Update all other rows to zero out the entering variable column
            for (int i = 0; i < numConstraints; i++)
            {
                if (i != leavingVarIndex)
                {
                    double factor = lhs[i, enteringVarIndex];
                    for (int j = 0; j < totalVars; j++)
                    {
                        lhs[i, j] -= factor * lhs[leavingVarIndex, j];
                    }
                    rhs[i] -= factor * rhs[leavingVarIndex];
                }
            }

            // Update the objective function coefficients
            double objectiveFactor = objCoeffs[enteringVarIndex];
            for (int j = 0; j < totalVars; j++)
            {
                objCoeffs[j] -= objectiveFactor * lhs[leavingVarIndex, j];
            }

            // Update the basic variables
            basicVariables[leavingVarIndex] = enteringVarIndex;
        }

        StoreSolution(basicVariables);
        Console.WriteLine("Dual Simplex Method completed.");
    }

    private void StoreSolution(int[] basicVariables)
    {
        optimalValue = 0;
        primalSolution = new double[totalVars];
        shadowPrices = new double[numConstraints];

        for (int i = 0; i < numConstraints; i++)
        {
            int varIndex = basicVariables[i];
            primalSolution[varIndex] = rhs[i];
            if (varIndex >= totalVars - numConstraints) // Slack variables
            {
                shadowPrices[i] = objCoeffs[varIndex];
            }
        }

        for (int i = 0; i < totalVars; i++)
        {
            optimalValue += objCoeffs[i] * primalSolution[i];
        }
    }

    public (double OptimalValue, double[] PrimalSolution, double[] ShadowPrices) GetSolutionDetails()
    {
        return (optimalValue, primalSolution, shadowPrices);
    }
}

